#!/usr/bin/env ruby

require 'optparse'
require 'cloudscopes'

def handle(samples)
  return Cloudscopes.publish(samples) if Cloudscopes.publish?
  samples.each do |category, samples|
    valid_data = samples.select(&:valid?)
    next if valid_data.empty?
    puts "#{category.rjust(10,' ')}: "
    valid_data.each { |s| puts "#{' '*12}#{s.name} - #{s.value} #{s.unit} (#{s.to_cloudwatch_metric_data})" }
  end
end

def exit_with_error(message)
  $stderr.puts(message)
  exit 1
end

publish = true
loop_period = nil
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] <config.yaml>\n\nOptions:"
  opts.on("-t", "--test", "Dump samples to the console instead of publishing") do
    publish = false
  end
  opts.on("-l", "--loop [PERIOD]", Integer,
      "Perform sampling every PERIOD (defaults to 60) seconds") do |period|
    period ||= 60
    if period < 10 || period > 86_400
      exit_with_error("The loop period must be a value from 10 to 86,400 seconds.")
    end
    loop_period = period
  end
  opts.on_tail("-?", "-h", "--help", "Show this message") do
    puts(opts)
    exit
  end
end
begin
  arguments = option_parser.parse!
rescue OptionParser::ParseError
  exit_with_error(option_parser)
end
exit_with_error(option_parser) unless arguments.size == 1

Cloudscopes.init(config_file: arguments.first, publish: publish)

if loop_period
  start_time = next_start_time = Time.now
  while true
    # fork to limit master memory usage
    Process.wait(fork { handle(Cloudscopes.samples) })
    while next_start_time <= start_time
      next_start_time = start_time + loop_period
    end
    sleep(next_start_time - Time.now)
    start_time = next_start_time
  end
else
  handle(Cloudscopes.samples)
end
